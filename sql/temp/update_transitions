
CREATE OR REPLACE FUNCTION bus.get_distance_between_stations(_station_a_id bigint, _station_b_id bigint)
RETURNS double precision AS
$BODY$
DECLARE
 _distance double precision;
 p1 geometry;
 p2 geometry;
BEGIN
 SELECT location INTO p1 FROM bus.stations where id = _station_a_id;
 IF NOT FOUND THEN
	return 1000000000000000000;
 END IF;
 SELECT location INTO p2 FROM bus.stations where id = _station_b_id;
 IF NOT FOUND THEN
	return 1000000000000000000;
 END IF;

 return st_distance(geography(p1),geography(p2));
END;
$BODY$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION bus.get_next_relation(_curr_relation_id integer,_station_b_id bigint)
RETURNS bus.route_relations AS
$BODY$
DECLARE
 _next_relation    bus.route_relations;
BEGIN
  SELECT * INTO _next_relation FROM bus.route_relations WHERE station_a_id = _station_b_id;
  IF NOT FOUND THEN
	return null;
  END IF;
  return _next_relation;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;


CREATE OR REPLACE FUNCTION bus.is_has_transition(_curr_relation_a_id integer, 
						 _curr_relation_b_id integer,
						 _max_distance      double precision
						 )
RETURNS integer AS
$BODY$
DECLARE
  _curr_relation_a    bus.route_relations%ROWTYPE;
  _curr_relation_b    bus.route_relations%ROWTYPE;
  
  _next_relation_a    bus.route_relations;
  _next_relation_b    bus.route_relations;
BEGIN
    SELECT * INTO _curr_relation_a FROM bus.route_relations WHERE id = _curr_relation_a_id;
  IF NOT FOUND THEN
	RAISE EXCEPTION 'function bus.get_next_relation(): Cannot find relation';
  END IF;
    SELECT * INTO _curr_relation_b FROM bus.route_relations WHERE id = _curr_relation_b_id;
  IF NOT FOUND THEN
	RAISE EXCEPTION 'function bus.get_next_relation(): Cannot find relation';
  END IF;
  _next_relation_a:= bus.get_next_relation(_curr_relation_a.id,_curr_relation_a.station_b_id);
  _next_relation_b:= bus.get_next_relation(_curr_relation_b.id,_curr_relation_b.station_b_id);
  IF _next_relation_a IS NOT NULL AND _next_relation_b IS NOT NULL THEN
	IF  ( bus.get_distance_between_stations(_curr_relation_a.station_b_id,_curr_relation_b.station_b_id) < _max_distance AND
	      bus.get_distance_between_stations(_next_relation_a.station_b_id,_next_relation_b.station_b_id) < _max_distance)
	    OR
	    ( bus.get_distance_between_stations(_curr_relation_a.station_b_id,_next_relation_b.station_b_id) < _max_distance AND
	      bus.get_distance_between_stations(_next_relation_a.station_b_id,_curr_relation_b.station_b_id) < _max_distance)
	THEN
	    return -1;
	END IF;
  END IF;
  return 1;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION bus.update_transitions_for_transport_test(_route_id     bigint,
								_route_type   	   bus.route_type_enum,
								_foot_speed        double precision,
								_max_distance      double precision
) RETURNS SETOF bus.graph_relations AS
$BODY$
DECLARE
  _graph_relation      bus.graph_relations%ROWTYPE;
  r                    bus.relation%ROWTYPE;
  relations            bus.relation[];
  i                    int;
  count                int;
  _row                 record;
  _city_id             bigint;
  _arr_types           bus.route_type_enum[];
BEGIN
_arr_types = array[bus.route_type_enum('c_route_metro'),bus.route_type_enum('c_route_metro_transition')];

-- get city_id
SELECT city_id INTO _city_id from bus.routes where id = _route_id;

-- add transitions between 'c_route_metro' and 'c_route_metro_transition'
IF _route_type = bus.route_type_enum('c_route_metro_transition') THEN
  

END IF;

-- get all nearest route_relations to current route 
FOR r IN
SELECT 
        r1.id                       as source,
        table2.relation_id          as target,
        st_distance(geography(table2.location),geography(bus.stations.location)) as  distance,
        _route_type                 as source_route_type,
	bus.routes.route_type_id    as target_route_type       
FROM    bus.route_relations  as r1
        JOIN bus.stations       ON bus.stations.id = r1.station_b_id
        JOIN bus.direct_routes  ON bus.direct_routes.id = r1.direct_route_id
        JOIN bus.routes         ON bus.routes.id = bus.direct_routes.route_id

        ,(select bus.route_relations.id      as relation_id, 
		  bus.stations.location      as location,
		  bus.direct_routes.route_id as route_id,
		  bus.direct_routes.id       as direct_route_id,
		  bus.stations.id            as station_id
		  from bus.route_relations
                  JOIN bus.stations  ON bus.stations.id = bus.route_relations.station_b_id 
                  JOIN bus.direct_routes  ON bus.direct_routes.id = bus.route_relations.direct_route_id
                  where bus.direct_routes.route_id = _route_id
           )as table2
	WHERE   bus.direct_routes.route_id <> table2.route_id AND
	        st_distance(geography(table2.location),geography(bus.stations.location)) < _max_distance AND
	        (bus.routes.route_type_id <> ALL(_arr_types) OR _route_type <> ALL(_arr_types))
	        
	LOOP
	  relations := array_append(relations,r);
	END LOOP;	     

-- insert reverse relations
  i:=1;
  count := array_upper(relations,1);
  WHILE i<= count LOOP
        r.source = relations[i].target;
        r.target = relations[i].source;
        relations := array_append(relations,r);
	i:= i + 1;
  END LOOP;

  -- return graph_relations
     FOR _graph_relation IN 
      select  
	      1 as id,
              _city_id as city_id,
	      bus.route_type_enum('c_route_foot') as route_type_id,
              relations.source as relation_a_id,
              relations.target as relation_b_id,
              bus.timetable.time_a as time_a,
              bus.timetable.time_b as time_b,
              bus.schedule_group_days.day_id      as day_id,
              (relations.distance/1000.0/_foot_speed*60) * interval '00:01:00'   + bus.timetable.frequency as move_time,
              bus.routes.cost
      from unnest(relations) as relations
              JOIN bus.route_relations as r1 ON  r1.id = relations.source
              JOIN bus.route_relations as r2 ON  r2.id = relations.target
              JOIN bus.direct_routes         ON bus.direct_routes.id = r2.direct_route_id
              JOIN bus.routes                ON bus.routes.id = bus.direct_routes.route_id
	      
	      JOIN bus.schedule              ON bus.schedule.direct_route_id = r2.direct_route_id
              JOIN bus.schedule_groups       ON bus.schedule_groups.schedule_id = bus.schedule.id
              JOIN bus.schedule_group_days   ON bus.schedule_group_days.schedule_group_id = bus.schedule_groups.id
              JOIN bus.timetable             ON bus.timetable.schedule_group_id = bus.schedule_groups.id    

              where r1.station_a_id IS NOT NULL  AND 
                    r2.station_a_id IS NOT NULL  AND
                    bus.is_has_transition(relations.source,relations.target, _max_distance/2.0) > 0
  LOOP
      RETURN NEXT _graph_relation;
  END LOOP;

  i:=1;
  count := array_upper(relations,1) ;
 WHILE i<= count LOOP
       r := relations[i];
       --RETURN NEXT r;
       i:= i + 1;
  END LOOP;



END;
$BODY$
LANGUAGE plpgsql VOLATILE;


select r1.station_b_id, r2.station_b_id,v1.value,v2.value,graph_relations.route_type_id,r1.direct_route_id,*
 from bus.update_transitions_for_transport_test(5,'c_route_bus',5,500) as graph_relations
    JOIN bus.route_relations as r1 ON r1.id = graph_relations.relation_a_id
    JOIN bus.route_relations as r2 ON r2.id = graph_relations.relation_b_id
    LEFT JOIN bus.stations  as st1 ON st1.id = r1.station_b_id
    LEFT JOIN bus.stations  as st2 ON st2.id = r2.station_b_id
    LEFT JOIN bus.string_values as v1 ON v1.key_id = st1.name_key
    LEFT JOIN bus.string_values as v2 ON v2.key_id = st2.name_key
where (graph_relations.day_id IS NULL  or graph_relations.day_id = day_enum('c_Sunday')) AND
    v1.lang_id = 'c_ru' and   v2.lang_id = 'c_ru' and graph_relations.route_type_id='c_route_foot';


	